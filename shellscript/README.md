# 基礎
シェルとは、カーネルがわかるようにコマンドを実行する環境で現在のスタンダードはbash


cshは欠陥品と呼ばれるレベルでバグを抱えているため絶対に採用してはならない</br>
`#!`はシバンと呼ばれる文字列でスクリプトの実行で使うインタプリタを指定する</br>
シェルスクリプトは思想的にコマンドを羅列しているという理解で進めるとエラーへの対処などがスムーズになる</br>
先達が意識しているポイント
1. シェルスクリプトはすべてコマンドの羅列である
2. シンタックスエラーではなくコマンドエラーとして考える
3. シェルスクリプトはコマンドライン・テンプレートである
4. 最終的にどのようなコマンドが実行されるかイメージする


if statement
```sh
#!/bin/bash

# 標準入力を受け取る
read str

if [ "$str" = "hoge" ]; then
    echo "hoge"
elif [ "$str" = "fuga" ]; then
    echo "fuga"
else
    echo "unknown"
fi
```
if文は上記のように記述されるif文の条件式である`[`もコマンドとして扱われるため必ずスペースが必要となる

case statement
```sh
#!/bin/bash

read str

case "$str" in
    "hoge" ) echo "hoge"
            echo "hoge" ;;
    "fuga" ) echo "" ;;
    * ) echo "unknown" ;;
esac
```
`*`は全文字列と一致するというワイルドカード
`;;`が各コマンド処理の区切り

for statement
```sh
#!/bin/bash

for i in 0 1 2 3
do
    echo $i
done
```

while statement
```sh
#!/bin/bash

while :
do
    read str

    if [ "$str" = "end" ]; then
        break
    fi
done
```


標準出力とエラー
`1`は標準出力で`2`がエラーを意味する

終了ステータスは`$?`で受け取れる

四則演算
```sh
#!/bin/bash

VAR_L=5
VAR_R=5

# 四則演算
echo $(( $VAR_L + $VAR_R ))
echo $(( $VAR_L - $VAR_R ))
echo $(( $VAR_L * $VAR_R ))
echo $(( $VAR_L / $VAR_R ))

```

変数
通常のプログラミング言語同様の命名ルールがある
スコープは基本的にグローバル変数

$を使ったアクセス
- $0　スクリプト名
- $#　渡されたパラメータの個数
- $$　プロセスID
- $1,$2,..$N　パラメータ
- $* クリプト実行時、指定されたパラメータ全てが設定される変数。
- $@　基本的に$*と同じ、“”で囲んだときの展開の動作が異なる

List型
```sh
#!/bin/bash

LIST_1=(aa bb cc)

echo ${LIST_1[0]}
echo ${LIST_1[1]}
echo ${LIST_1[2]}
```

sedを使ってテキストファイルの編集を行える

置換
```sh
sed -e 's/code/script/g' ./test.txt
```

対象行削除
```sh
sed -e 's/code/d' ./test.txt
```

関数
```sh
#!/bin/bash

function hello_world () {
    echo "$1" # arguments are accessible through $1, $2,...
}

hello_world aaa
```
シェルスクリプトの思想上なるべくシンプルなものが求められるため関数ものその思想に則る必要がある
シェルスクリプトの関数の特性
- 戻り値は基本的に存在しない
- 関数内の変数もグローバル変数として扱われる
  - 変数定義時に`local var=1`のように宣言すればスコープをローカルに絞れる
アンチパターンとして関数を複雑にするというのがあるが上記思想に則って考えればわかる

## 学習に使っているもの
- [【1分でわかる】シェルスクリプトとは？](https://eng-entrance.com/linux-shellscript-what)
- [３分間で人に説明できるようになるUnixとLinuxの違い](https://eng-entrance.com/unix_linux)
- [bash シェルスクリプト入門 -シェルスクリプトのいろは-](https://shellscript.sunone.me/tutorial.html)
- [【初心者でもわかる】Linuxシェルスクリプト入門 まとめました](https://eng-entrance.com/category/linux/linux-shellscript)

# 初級
## 標準入出力とエラー
- 0 標準入力
- 1 標準出力
- 2 エラー

シェルスクリプトでは上記の番号で予約されている。
また、標準出力とエラーを同時に出力したい場合は`command > log.txt 2>&1`と記述するとできる。

## リダイレクト
標準出力やエラーを任意の状態で出力したいときに使われる。
ファイル名を指定するとファイルが生成され出力された内容を保存する

出力の種類
- `>` 生成して出力する
- `>>` 末尾に出力する

## パイプライン
2つ以上のコマンドをつないで処理するときに使う。
`|`でコマンドを繋ぐことで直前のコマンドの標準出力を標準入力として受け取ってコマンドが実行される。

## フィルタ
標準出力を特定の条件でフィルタリングするコマンド

- cat そのまま出力
- head 先頭n行を出力
- tail 末尾n行を出力
- grep 指定した検索パターンに一致する行を出力
- sort 順番を並べ替える
- uniq 重複した行を取り除く
- tac 逆順で出力
- wc 行数やバイトを出力

使用例

duでファイルサイズを取得してそこからサイズの大きいものを5行分出力する
```
du -b ./* | sort -n | tac | head -n 5
```

## cut
入力行の区切り文字と列を指定して出力する

`cut -d : -f 7 /etc/passwd`

また、`-f 1,2,3`のように複数列を指定できる

## ファイル監視
ファイル監視で追加分の監視が行われることがある。
`tail -f text.txt`
上記コマンドを実行すると実行状態となりファイルの追加分をどんどん標準出力していく

## サーチパスに独自のシェルスクリプトを配置する
`/dir/bin`任意のディレクトリを選択するそこにシェルスクリプトを配置する
以下のようなディレクトリ構造を作る
```
/dir+
    |
    + bin +
          |
          + shellscript.sh
```
これをサーチパスに設定することで`shellscript.sh`でコマンド実行のように独自のシェルスクリプトを実行できる

サーチパスへの登録方法
```
PATH="$PATH:/dir/bin"
source ~/.bash_profile
```

`$PATH:/dir/bin`はPATH変数に任意のディレクトリを追記している記述となるのでこの変更を.bash_profileに反映させれば後は上述したようにshellscript.shでどこからでも実行できるようになる

## コマンド置換
`$()`を用いることでコマンドの結果を使って任意の形式ものを出力できる。
```sh
#!/bin/bash

today=$(date '+%Y-%m-%d')
echo "$today"
```

# 中級
## 位置パラメータ
引数と同様の意味で$1と記述するとその番号に合わせて入力された順のパラメータを取得できる</br>
特殊のアクセス方法とパラメータ
- $*: 全入力パラメータを1つの文字列として取得する
- $@: 全入力パラメータを1つずつ文字列として取得する
- $#: パラメータの個数
- $?: 終了ステータス
- $$: 現在のプロセスID
- $!: 最後に実行したバックグラウンドコマンドのプロセスID

## 変数宣言
変数に属性も持たせるために使う</br>
例えば配列の宣言、整数の宣言など
```sh
#!/bin/bash

declare -i num
num=5
echo $num

declare -a arr1
arr1=(apple banana)
echo ${arr1[0]}
echo ${arr1[1]}

declare -A dict1
dict1=([id]=5 [name]=miyake)
echo ${dict1[id]}
echo ${dict1[name]}
```

## 配列
基本的な形
```
arr=(a b c)

>>  a
    b
    c
```
スペースで要素を区切る

アクセス
```
${arr[1]}

>>  b

${arr[*]}

>>  a b c
${#arr[@]}
>> 3
```
[]で要素へアクセスでき、*(@でも同じ)で指定すると全要素を出力する。<br/>
また、@の特殊文字を使うと要素数を取得できる。

```
arr=(a [2]=b [3]=c)

>>  a

    b
    c
```
代入先の要素を指定することができ何も代入されない要素は自動で空文字が入る


要素の追加
```
arr1=(aa bb "${arr[@]}")

>>  aa
    bb
    a

    b
    c

arr1+=(cc dd)

>>  aa
    bb
    a

    b
    c
    cc
    dd

arr1=(aa bb [4]="${arr[@]}")

>>  aa
    bb


    a

    b
    c

echo ${arr1[4]}

>>  a

    b
    c
```
既存の配列と組み合わせて要素の追加が行えアクセスする要素番号は配列を作る際に配置する箇所に応じて決まる<br/>
また、要素番号を指定して既存の配列を代入するとその要素番号にネストされる

要素の削除
```
unset arr[2]
>>  a
    

    c
```
要素の削除はその要素番号に代入されている値を空文字にする処理を行う

値が存在するインデックスの取得
```
echo ${!arr[@]}

>> 0 3
```
空文字以外のインデックスを取得できる

## 連想配列
```
declare -A user=([id]=3 [name]=test)
echo ${user[id]}
>>  3
```
名前を持ったインデックスで要素を格納でき操作は配列と同様に行える

## プロセス置換
`<`を用いることで一時ファイルを生成して対象のコマンドに標準入力される
```
diff <(ls ./) <(ls /)

# diffの結果
>> ----
```
パイプラインだと入力が1つだがプロセス置換であれば`<`を複数入力できる

## &&と||
`&&`でコマンドをつなげると直前のコマンドが成功したときだけ次のコマンドが実行される</br>
`||`は、その逆で失敗しときにコマンドを実行する

また、`[[]]`で囲むことでAND, ORのようにif文の評価式としても使える

## `[[]]`
条件式を`[[]]`で囲むことで変数展開で発生するクォートのエラー回避やパターンマッチによる評価が可能となる


## 標準入出力
Linuxはハードウェア含めてカーネル上で全てファイルとして扱うそのため入出力はカーネル上でみると全てファイル上のやり取りとして解釈される</br>
この事より標準入出力はファイルへの入出力として基本的にはカーネルを介して入力はキーボード、出力は端末ディスプレイで設定されているがその先をファイルに置き換えることができる。

この置き換えをリダイレクトという。

## リダイレクト
`>`を用いるとコマンドの出力先をファイルに変更できる。</br>
`<`にするとコマンドにファイルの入力を用いることができる。

`>`は上書き保存となるため追記したい場合は`>>`を使う

また、上書き保存を禁止したい場合は、`set noclobber`を先に設定しておくと上書きをエラーとして返す

`n>$m`n番目の出力をm番目の入力として扱う

`&>`と記述すると標準出力と標準エラーをまとめて出力できる</br>
また、`&>>`とすると追記で出力ができる

`/dev/null`は何も出力しないファイルとなるためここに出力が不要なものをリダイレクトさせると表示をスッキリさせることができる

リダイレクトで優先的に実行されるのは出力先の設定となるため以下のようなコマンドを記述すると何も出力されない
```
echo abcd > word.txt
tr b B < word.txt > word.txt

>> 
```

## パイプライン
`|`でコマンドを繋ぐことで標準出力を次のコマンドの標準入力として扱うことができる

リダイレクトと挙動が似ているが違いとしてファイル生成を省くことができる

## ヒアドキュメント
```
command << END
documents....
...
END
```
上記コマンドに対して複数行の標準入力が行える</br>
最後終了を示すENDは1行独立で記述する必要がある

## コマンドのグループ化
複数コマンドの出力をまとめたい場合以下のように`{}`で囲むとまとめることができる
```sh
#!/bin/bash

{
    date +%Y-%m-%d
    echo '/usr list'
    ls /usr
} > result.txt
```

`()`を使うとカッコ内はサブシェルとして実行されるためその間のディレクトリ移動などはサブシェル終了後に親シェルの状態に戻る

## ブレース展開
```
echo file-{1001, 1002}

>> file-1001 file-1002
```
{}で囲んで,で文字列を区切って複数の文字列を生成できる

