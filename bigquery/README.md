# BigQueryの構成要素
1. Dremel→コンピューティング
2. Colossus→分散ストレージ
3. Jupiter network→ネットワーク
4. Borg→オーケストレーション

# 動的クエリ実行について
ユーザー側がシステムを考慮してデータの扱いやクエリを気にかける必要はなくDremelでそういった部分はメタデータを用いながらクエリの各段階を自動的に構成されます。そのためユーザーはクエリの実行速度や消費するスロットに注意してクエリを作ることになります。

# データセットのアクセス制御
GCPで使われるアクセス制御のIAMでデータセットのアクセスを制御します。

管理のベストプラクティスとしては、BQリソースは組織単位からの管理を開始してそれ以降を用途に応じて制限する方法を取ります。

# スロット
BQのクエリはDremel内のvCPU一つにつき1スロットと計算してそれらをクエリにてどれだけ使うかがリソース使用の1つの要因となります。

料金モデルに応じてスロットの消費方法は変わります。

BQのクエリは動的DAGが用いられ最適並列化数を計算してそれに合わせて分散実行がされます。

消費スロットは料金サービスによりますがその時扱えるスロット数と最適並列化数の兼ね合いで順次実行されます。

# クエリの費用を下げる
- SELECT *を避ける

    LIMIT句を使ってもスキャン量は変わらないため必要なデータのみ読み取るようにする
- テーブルを日付別のパーティショニングにする

    日付別にすることでクエリ対象とするテーブルが絞れるため更にスキャン量を減らせる

- データの確認にはプレビューで行う

    bqコマンドを使ってbq headでプレビューする行数を設定できる

- bq --dry_runでクエリを見積もる

    --dry_runでクエリで処理されるバイト数の見積もりが計算されるためそれを料金計算ツール用いてコスト計算することができる
- 課金されるバイト数の制限を設定する
- クラスタ化の検討とLIMIT句の使用

    パーティショニングと同様にクラスタにすることでテーブルのスキャン量を減らせる。また、クラスタテーブルであればLIMIT句でもスキャン量が減る。
- ダッシュボードによる監視
- クエリ結果を段階的にテーブルとして保存して分割して実行されるようにする
- テーブルの有効期限を設定して古いものを自動削除するように設定する
- データストリーミングは料金が発生するため必要性を検討する

# クエリパフォーマンス
クエリで発生する操作が少ないほどパフォーマンスが良くなります。操作量は以下の要因などから決まっていきます。
- 入力データとデータソース（I/O）: クエリで何バイト読み取るか。
- ノード間の通信（シャッフル）: クエリから次の段階に何バイト転送するか。クエリは各スロットに何バイトずつ渡すか。
- コンピューティング: クエリにはどのくらいの CPU 作業が必要か。
- 出力（実体化）: クエリは何バイト書き込むか。
- クエリのアンチパターン: クエリは SQL のベスト プラクティスに従っているか。

## 入力データとデータソース（I/O）
- データの確認にはプレビューもしくはbq head用いてサンプリングされたデータを確認する
- テーブルは日付パーティショニングを行う
    
    日付パーティショニングされたテーブルは以下のようなクエリを使って特定の範囲を抜き出せます。
    ```sql
    WHERE _PARTITIONTIME
    BETWEEN TIMESTAMP("2016-01-01")
        AND TIMESTAMP("2016-01-31")
    ```
- データ非正規化にする

    正規化されたデータをネストされたフィールドもしくは繰り返しフィールドを使って非正規化に変換します。正規化されたデータではデータ結合が発生しデータ通信が発生するため非正規化と比べパフォーマンスが低下します。</br>
    また、非正規化に変換するときには完全にフラットなデータではなくネストされたフィールドもしくは繰り返しフィールドを使うとシャッフルによるクエリパフォーマンス低下に対応できる可能性があります。</br>
    ただ、以下のようなケースでは非正規化でのパフォーマンス向上が見込めない可能性があります。
    - 頻繁にディメンションが変化するスタースキーマがある場合。
    - BigQuery が行レベルの変更（ミューテーション）があるオンライン トランザクション処理（OLTP）システムを補完しているが、それに置き換えることはできない場合。
- ネストフィールドと繰り返しフィールドの活用

    - ネストデータ(STRUCT型)
    - 繰り返しデータ(ARRAY型)

# Ref
- [Separation of storage and compute in BigQuery](https://cloud.google.com/blog/products/bigquery/separation-of-storage-and-compute-in-bigquery)
- [スロット](https://cloud.google.com/bigquery/docs/slots)
- [BigQuery リソースの整理](https://cloud.google.com/bigquery/docs/resource-hierarchy)
- [BigQuery で費用を抑える](https://cloud.google.com/bigquery/docs/best-practices-costs)