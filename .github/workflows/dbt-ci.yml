# =============================================================================
# dbt CI Workflow
# =============================================================================
# Áã¨Á´ã„Åó„Åü3„Å§„ÅÆ„Ç∏„Éß„Éñ„ÅßÊßãÊàê:
# 1. dbt-test: „É¢„Éá„É´„Éì„É´„Éâ + „ÉÜ„Çπ„ÉàÔºàdeferÊà¶Áï•Ôºâ
# 2. sdf-lint: SDF Lint„Å´„Çà„Çã„É™„É≥„Çø„Éº„Éª„Éï„Ç©„Éº„Éû„ÉÉ„Çø„Éº
# 3. dbt-evaluator: dbt_project_evaluator„Å´„Çà„ÇãÊßãÊàêÈÅïÂèç„ÉÅ„Çß„ÉÉ„ÇØ
# =============================================================================

name: dbt CI

on:
  pull_request:
    branches: [main]

  push:
    branches: [main]
    paths:
      - 'dbt-ci-test/dbt_ci_test/models/**'
      - 'dbt-ci-test/dbt_ci_test/macros/**'
      - 'dbt-ci-test/dbt_ci_test/tests/**'
      - 'dbt-ci-test/dbt_ci_test/seeds/**'
      - 'dbt-ci-test/dbt_ci_test/snapshots/**'
      - 'dbt-ci-test/dbt_ci_test/dbt_project.yml'
      - 'dbt-ci-test/dbt_ci_test/packages.yml'
      - 'dbt-ci-test/dbt_ci_test/selectors.yml'
      - '.github/workflows/dbt-ci.yml'

  workflow_dispatch:
    inputs:
      target:
        description: 'dbt target (ci/dev/prod)'
        required: false
        default: 'ci'
        type: choice
        options:
          - ci
          - dev
          - prod
      run_dbt_test:
        description: 'Run dbt Build & Test job'
        required: false
        default: true
        type: boolean
      run_sdf_lint:
        description: 'Run SDF Lint job'
        required: false
        default: true
        type: boolean
      run_evaluator:
        description: 'Run dbt Project Evaluator job'
        required: false
        default: true
        type: boolean
      full_build:
        description: 'Run full build (ignore defer)'
        required: false
        default: false
        type: boolean
      dataset_suffix:
        description: 'Dataset suffix (e.g., pr123, manual)'
        required: false
        default: 'manual'
        type: string

env:
  DBT_PROFILES_DIR: ${{ github.workspace }}/dbt-ci-test/dbt_ci_test
  DBT_BQ_PROJECT: ${{ secrets.GCP_PROJECT_ID }}
  DBT_BQ_DATASET: dbt_ci_${{ github.event.inputs.dataset_suffix || format('pr{0}', github.event.pull_request.number) }}
  DBT_BQ_LOCATION: asia-northeast1

defaults:
  run:
    working-directory: dbt-ci-test/dbt_ci_test

jobs:
  # ===========================================================================
  # Job 0: prod manifest„ÅÆÊõ¥Êñ∞ÔºàÂÖ®„Ç∏„Éß„Éñ„ÅÆÂâçÊèêÊù°‰ª∂Ôºâ
  # ===========================================================================
  update-prod-manifest:
    name: Update Prod Manifest
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.head_ref || github.ref }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: pip install dbt-bigquery

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIP_DBT }}
          service_account: ${{ secrets.WIP_SA_DBT }}

      - name: dbt deps
        run: dbt deps

      # Êú¨Áï™Áí∞Â¢É„Çí„Çø„Éº„Ç≤„ÉÉ„Éà„Å´parseÂÆüË°å
      - name: dbt parse (prod)
        run: dbt parse --target prod

      # manifest.json„Çíprod_state„Éá„Ç£„É¨„ÇØ„Éà„É™„Å´„Ç≥„Éî„Éº
      - name: Update prod_state/manifest.json
        run: |
          mkdir -p prod_state
          cp target/manifest.json prod_state/manifest.json
          echo "‚úÖ Updated prod_state/manifest.json"

      # Â§âÊõ¥„Åå„ÅÇ„Çå„Å∞„Ç≥„Éü„ÉÉ„Éà
      - name: Commit manifest update
        working-directory: .
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          if git diff --quiet dbt-ci-test/dbt_ci_test/prod_state/manifest.json; then
            echo "No changes to manifest.json"
          else
            git add dbt-ci-test/dbt_ci_test/prod_state/manifest.json
            git commit -m "chore: update prod_state/manifest.json

            Auto-generated by GitHub Actions"
            git push
            echo "‚úÖ Committed and pushed manifest.json update"
          fi

      - name: Output summary
        run: |
          echo "## üì¶ Prod Manifest Update" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ prod_state/manifest.json is up to date" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # Job 1: dbt TestÔºà„É¢„Éá„É´„Éì„É´„Éâ + „ÉÜ„Çπ„ÉàÔºâ
  # ===========================================================================
  dbt-test:
    name: dbt Build & Test
    runs-on: ubuntu-latest
    needs: [update-prod-manifest]
    if: ${{ always() && needs.update-prod-manifest.result == 'success' && (github.event_name == 'pull_request' || github.event_name == 'push' || github.event.inputs.run_dbt_test == 'true') }}
    permissions:
      contents: read
      pull-requests: write
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref }}

      # ÊúÄÊñ∞„ÅÆÂ§âÊõ¥„ÇíÂèñÂæóÔºàupdate-prod-manifest„Åßpush„Åï„Çå„ÅüÂ§âÊõ¥„ÇíÂê´„ÇÄÔºâ
      - name: Pull latest changes
        working-directory: .
        run: git pull origin ${{ github.head_ref || github.ref_name }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: pip install dbt-bigquery

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIP_DBT }}
          service_account: ${{ secrets.WIP_SA_DBT }}

      - name: dbt deps
        run: dbt deps

      # prod_state„Åã„Çâmanifest.json„ÇíÂèñÂæóÔºàupdate-prod-manifest„ÅßÊõ¥Êñ∞Ê∏à„ÅøÔºâ
      - name: Check prod manifest
        id: check-manifest
        run: |
          if [ -f "prod_state/manifest.json" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      # dbt compileÔºàmanifest.jsonÁîüÊàêÔºâ
      - name: dbt compile
        run: dbt compile --target ${{ github.event.inputs.target || 'ci' }}

      # dbt buildÔºàÂ§âÊõ¥ÂàÜ„ÅÆ„Åø„ÄÅdeferÊà¶Áï•Ôºâ
      - name: dbt build (slim CI with defer)
        id: dbt-build
        if: steps.check-manifest.outputs.exists == 'true' && github.event.inputs.full_build != 'true'
        run: |
          set +e
          dbt build \
            --selector ci_slim \
            --defer \
            --state ./prod_state \
            --target ${{ github.event.inputs.target || 'ci' }} 2>&1 | tee dbt_build_output.txt
          EXIT_CODE=${PIPESTATUS[0]}
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT
          exit 0

      # „Éï„É´„Éì„É´„ÉâÔºàprod manifest„Åå„Å™„ÅÑÂ†¥Âêà„ÄÅ„Åæ„Åü„ÅØfull_buildÊåáÂÆöÊôÇÔºâ
      - name: dbt build (full - no defer)
        id: dbt-build-full
        if: steps.check-manifest.outputs.exists == 'false' || github.event.inputs.full_build == 'true'
        run: |
          set +e
          dbt build \
            --exclude package:dbt_project_evaluator \
            --target ${{ github.event.inputs.target || 'ci' }} 2>&1 | tee dbt_build_output.txt
          EXIT_CODE=${PIPESTATUS[0]}
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT
          exit 0

      # ÁµêÊûú„Çí„Éë„Éº„Çπ
      - name: Parse build results
        id: parse-results
        run: |
          python3 << 'EOF'
          import re
          import os

          with open('dbt_build_output.txt', 'r') as f:
              output = f.read()

          # „É¢„Éá„É´ÁµêÊûú
          model_pass = len(re.findall(r'OK created', output))
          model_fail = len(re.findall(r'ERROR creating', output))
          failed_models = re.findall(r'ERROR creating [\w\.]+ model (\w+)', output)

          # „Éá„Éº„Çø„ÉÜ„Çπ„ÉàÁµêÊûúÔºàdata test„ÅÆ„ÅøÔºâ
          # dbtÂá∫Âäõ„Åã„Çâ data test „Å® unit test „ÇíÂå∫Âà•
          data_test_pass = len(re.findall(r'PASS .*?data test', output, re.IGNORECASE))
          data_test_fail = len(re.findall(r'FAIL .*?data test', output, re.IGNORECASE))
          data_test_warn = len(re.findall(r'WARN .*?data test', output, re.IGNORECASE))
          failed_data_tests = re.findall(r'Failure in test (?!.*unit)(\w+)', output)

          # „É¶„Éã„ÉÉ„Éà„ÉÜ„Çπ„ÉàÁµêÊûú
          unit_test_pass = len(re.findall(r'PASS .*?unit test', output, re.IGNORECASE))
          unit_test_fail = len(re.findall(r'FAIL .*?unit test', output, re.IGNORECASE))
          failed_unit_tests = re.findall(r'Failure in unit test (\w+)', output)

          # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÂÄãÂà•„Éë„Çø„Éº„É≥„Åß„Éû„ÉÉ„ÉÅ„Åó„Å™„ÅÑÂ†¥Âêà„ÅØÁ∑èÊï∞„Åã„ÇâÊé®Ê∏¨
          total_pass = len(re.findall(r'\[32mPASS', output)) or len(re.findall(r'PASS \d+', output))
          total_fail = len(re.findall(r'\[31mFAIL', output)) or len(re.findall(r'FAIL \d+', output))
          total_warn = len(re.findall(r'\[33mWARN', output)) or len(re.findall(r'WARN \d+', output))

          # ÂÄãÂà•„Ç´„Ç¶„É≥„Éà„Åå„Å™„ÅÑÂ†¥Âêà„ÅØ„Éà„Éº„Çø„É´„Çí‰ΩøÁî®
          if data_test_pass == 0 and unit_test_pass == 0:
              data_test_pass = total_pass
              data_test_fail = total_fail
              data_test_warn = total_warn
              failed_data_tests = re.findall(r'Failure in test (\w+)', output)

          # ÁµêÊûú„Çí„Éï„Ç°„Ç§„É´„Å´Âá∫Âäõ
          with open('build_report.md', 'w') as f:
              f.write("## üî® dbt Build Results\n\n")

              # Models
              f.write("### Models\n")
              if model_fail == 0:
                  f.write(f"‚úÖ **{model_pass}** models succeeded\n\n")
              else:
                  f.write(f"‚ùå **{model_fail}** failed, **{model_pass}** succeeded\n\n")
                  if failed_models:
                      f.write("<details>\n<summary>Failed Models</summary>\n\n")
                      for m in failed_models:
                          f.write(f"- `{m}`\n")
                      f.write("\n</details>\n\n")

              # Data Tests
              f.write("### Data Tests\n")
              if data_test_fail == 0:
                  f.write(f"‚úÖ **{data_test_pass}** tests passed")
                  if data_test_warn > 0:
                      f.write(f", **{data_test_warn}** warnings")
                  f.write("\n\n")
              else:
                  f.write(f"‚ùå **{data_test_fail}** failed, **{data_test_pass}** passed\n\n")
                  if failed_data_tests:
                      f.write("<details>\n<summary>Failed Data Tests</summary>\n\n")
                      for t in failed_data_tests:
                          f.write(f"- `{t}`\n")
                      f.write("\n</details>\n\n")

              # Unit Tests
              f.write("### Unit Tests\n")
              if unit_test_fail == 0 and unit_test_pass == 0:
                  f.write("‚ÑπÔ∏è No unit tests executed\n\n")
              elif unit_test_fail == 0:
                  f.write(f"‚úÖ **{unit_test_pass}** unit tests passed\n\n")
              else:
                  f.write(f"‚ùå **{unit_test_fail}** failed, **{unit_test_pass}** passed\n\n")
                  if failed_unit_tests:
                      f.write("<details>\n<summary>Failed Unit Tests</summary>\n\n")
                      for t in failed_unit_tests:
                          f.write(f"- `{t}`\n")
                      f.write("\n</details>\n\n")

          print("Build report generated")
          EOF

      # PR„Ç≥„É°„É≥„ÉàÔºàPR„Éà„É™„Ç¨„ÉºÊôÇ„ÅÆ„ÅøÔºâ
      - name: Post build results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('build_report.md', 'utf8');

            // Êó¢Â≠ò„Ç≥„É°„É≥„Éà„ÇíÊ§úÁ¥¢
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('dbt Build Results')
            );

            const body = `${report}\n\n---\n*Generated by dbt CI - Build & Test*`;

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      # push/workflow_dispatchÊôÇ„ÅØÁµêÊûú„Çí„Çµ„Éû„É™„Éº„Å´Âá∫Âäõ
      - name: Output build results (non-PR trigger)
        if: github.event_name != 'pull_request'
        run: |
          cat build_report.md >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # Job 2: SDF LintÔºà„É™„É≥„Çø„Éº„Éª„Éï„Ç©„Éº„Éû„ÉÉ„Çø„ÉºÔºâ
  # ===========================================================================
  sdf-lint:
    name: SDF Lint & Format
    runs-on: ubuntu-latest
    needs: [update-prod-manifest]
    if: ${{ always() && needs.update-prod-manifest.result == 'success' && (github.event_name == 'pull_request' || github.event_name == 'push' || github.event.inputs.run_sdf_lint == 'true') }}
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref }}

      # ÊúÄÊñ∞„ÅÆÂ§âÊõ¥„ÇíÂèñÂæóÔºàupdate-prod-manifest„Åßpush„Åï„Çå„ÅüÂ§âÊõ¥„ÇíÂê´„ÇÄÔºâ
      - name: Pull latest changes
        working-directory: .
        run: git pull origin ${{ github.head_ref || github.ref_name }}

      - name: Install SDF
        run: curl -LSfs https://cdn.sdf.com/releases/download/install.sh | sh -s

      - name: Add SDF to PATH
        run: echo "$HOME/.sdf/bin" >> $GITHUB_PATH

      - name: Run SDF format
        id: sdf-format
        run: |
          set +e
          ~/.sdf/bin/sdf format --save 2>&1 | tee sdf_format_output.txt
          echo "formatted=true" >> $GITHUB_OUTPUT

      - name: Check for formatting changes
        id: check-changes
        working-directory: .
        run: |
          if git diff --quiet; then
            echo "changes=false" >> $GITHUB_OUTPUT
          else
            echo "changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit formatting changes
        if: steps.check-changes.outputs.changes == 'true'
        working-directory: .
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add -A
          git commit -m "style: auto-format SQL files with SDF"
          git push

      - name: Run SDF lint
        id: sdf-lint
        run: |
          set +e
          ~/.sdf/bin/sdf lint 2>&1 | tee sdf_lint_output.txt
          EXIT_CODE=$?
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT
          exit 0

      - name: Parse lint results
        id: parse-lint
        run: |
          python3 << 'EOF'
          import re

          with open('sdf_lint_output.txt', 'r') as f:
              output = f.read()

          # „Ç®„É©„Éº/Ë≠¶Âëä„ÇíÊäΩÂá∫
          errors = re.findall(r'error:.*', output)
          warnings = re.findall(r'warning:.*', output)

          with open('lint_report.md', 'w') as f:
              f.write("## üîç SDF Lint Results\n\n")

              if not errors and not warnings:
                  f.write("‚úÖ All lint checks passed!\n")
              else:
                  if errors:
                      f.write(f"‚ùå **{len(errors)}** errors found\n\n")
                      f.write("<details>\n<summary>Lint Errors</summary>\n\n")
                      f.write("```\n")
                      for e in errors[:20]:  # ÊúÄÂ§ß20‰ª∂
                          f.write(f"{e}\n")
                      f.write("```\n\n</details>\n\n")

                  if warnings:
                      f.write(f"‚ö†Ô∏è **{len(warnings)}** warnings\n\n")
                      f.write("<details>\n<summary>Lint Warnings</summary>\n\n")
                      f.write("```\n")
                      for w in warnings[:20]:
                          f.write(f"{w}\n")
                      f.write("```\n\n</details>\n")

          print("Lint report generated")
          EOF

      - name: Post lint results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('lint_report.md', 'utf8');
            const formatted = '${{ steps.check-changes.outputs.changes }}' === 'true';

            let body = report;
            if (formatted) {
              body = "üìù **Auto-formatted SQL files** (committed automatically)\n\n" + body;
            }
            body += "\n\n---\n*Generated by dbt CI - SDF Lint*";

            // Êó¢Â≠ò„Ç≥„É°„É≥„Éà„ÇíÊ§úÁ¥¢
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('SDF Lint Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      # push/workflow_dispatchÊôÇ„ÅØÁµêÊûú„Çí„Çµ„Éû„É™„Éº„Å´Âá∫Âäõ
      - name: Output lint results (non-PR trigger)
        if: github.event_name != 'pull_request'
        run: |
          echo "## üîç SDF Lint Results" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.check-changes.outputs.changes }}" == "true" ]; then
            echo "üìù **Auto-formatted SQL files**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          cat lint_report.md >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # Job 3: dbt_project_evaluatorÔºàÊßãÊàêÈÅïÂèç„ÉÅ„Çß„ÉÉ„ÇØÔºâ
  # ===========================================================================
  dbt-evaluator:
    name: dbt Project Evaluator
    runs-on: ubuntu-latest
    needs: [update-prod-manifest]
    if: ${{ always() && needs.update-prod-manifest.result == 'success' && (github.event_name == 'pull_request' || github.event_name == 'push' || github.event.inputs.run_evaluator == 'true') }}
    permissions:
      contents: read
      pull-requests: write
      id-token: write

    env:
      DBT_PROJECT_EVALUATOR_SEVERITY: warn

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref || github.ref }}

      # ÊúÄÊñ∞„ÅÆÂ§âÊõ¥„ÇíÂèñÂæóÔºàupdate-prod-manifest„Åßpush„Åï„Çå„ÅüÂ§âÊõ¥„ÇíÂê´„ÇÄÔºâ
      - name: Pull latest changes
        working-directory: .
        run: git pull origin ${{ github.head_ref || github.ref_name }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: pip install dbt-bigquery

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIP_DBT }}
          service_account: ${{ secrets.WIP_SA_DBT }}

      - name: dbt deps
        run: dbt deps

      - name: dbt compile
        run: dbt compile --target ${{ github.event.inputs.target || 'ci' }}

      - name: Run dbt_project_evaluator
        id: evaluator
        run: |
          set +e
          dbt build \
            --selector evaluator \
            --target ${{ github.event.inputs.target || 'ci' }} 2>&1 | tee evaluator_output.txt
          EXIT_CODE=$?
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT
          exit 0

      - name: Parse evaluator results
        id: parse-evaluator
        run: |
          python3 << 'EOF'
          import re

          with open('evaluator_output.txt', 'r') as f:
              output = f.read()

          # „ÉÜ„Çπ„ÉàÁµêÊûú„ÇíÊäΩÂá∫
          failures = re.findall(r'Failure in test (fct_\w+)', output)
          warnings = re.findall(r'Warning in test (fct_\w+)', output)
          passes = len(re.findall(r'PASS fct_', output))

          with open('evaluator_report.md', 'w') as f:
              f.write("## üìä dbt Project Evaluator Results\n\n")

              if not failures and not warnings:
                  f.write("‚úÖ All best practice checks passed!\n\n")
                  f.write(f"**{passes}** rules checked\n")
              else:
                  if failures:
                      f.write(f"‚ùå **{len(failures)}** violations found\n\n")
                      f.write("<details>\n<summary>Violations</summary>\n\n")
                      for fail in failures:
                          # „É´„Éº„É´Âêç„ÇíË™≠„Åø„ÇÑ„Åô„ÅèÂ§âÊèõ
                          rule_name = fail.replace('fct_', '').replace('_', ' ').title()
                          f.write(f"- {rule_name}\n")
                      f.write("\n</details>\n\n")

                  if warnings:
                      f.write(f"‚ö†Ô∏è **{len(warnings)}** warnings\n\n")
                      f.write("<details>\n<summary>Warnings</summary>\n\n")
                      for warn in warnings:
                          rule_name = warn.replace('fct_', '').replace('_', ' ').title()
                          f.write(f"- {rule_name}\n")
                      f.write("\n</details>\n")

          print("Evaluator report generated")
          EOF

      - name: Post evaluator results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('evaluator_report.md', 'utf8');

            const body = `${report}\n\n---\n*Generated by dbt CI - Project Evaluator*`;

            // Êó¢Â≠ò„Ç≥„É°„É≥„Éà„ÇíÊ§úÁ¥¢
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('dbt Project Evaluator Results')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      # push/workflow_dispatchÊôÇ„ÅØÁµêÊûú„Çí„Çµ„Éû„É™„Éº„Å´Âá∫Âäõ
      - name: Output evaluator results (non-PR trigger)
        if: github.event_name != 'pull_request'
        run: |
          cat evaluator_report.md >> $GITHUB_STEP_SUMMARY
